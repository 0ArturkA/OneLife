Messages in ascii.

Terminated by # character


NOTE:

Wherever an object_id is menioned (o_id, new_id, etc), it can be either
a single ASCII-base-10 integer, OR a comma-delimited list of integers.

The first one is the base object ID (can be 0 if no object there),
and subsequent IDs are the objects contained in that object


HMAC_SHA1 below is the SHA-1 based HMAC as defined in RFC 2104, with the
resulting hash in hex-encoded ASCII.
The parameters are as follows:

char *HMAC_SHA1( char *inKey, char *inData )





Client login proceedure.

1.  Upon receiving a client connection, the server will immediately send
    a sequence number to the client in the following format:
    
SN
sequence_number
#

Where sequence_number is a positive integer in base-10 ascii.


2.  The client MUST respond with the following login message:

LOGIN email password_hash account_key_hash#


password_hash is based on the server access password, and is computed by:

HMAC_SHA1( password, sequence_number )


account_key_hash is based on the client's account key, all uppercase with
hyphens removed, and is computed by:

HMAC_SHA1( account_key, sequence_number )


3.  The server responds with one of:

ACCEPTED
#

-or-

REJECTED
#


After ACCEPTED, normal client-server messaging commences.

After REJECTED, the server will close the connection to the client.





Each message from server is prefaced by a type tag.

Possible types include:

MAP_CHUNK  (MC)

PLAYER_UPDATE  (PU)

PLAYER_MOVES_START (PM)

PLAYER_SAYS (PS)

MAP_CHANGE (MX)

FOOD_CHANGE (FX)



Client can expect to receive these at any time, and in any order.



MC
size x y
binary_raw_size binary_compressed_size 
#
COMPRESSED_BINARY_DATA


Where:
Chunk includes a size X size number of ids (a square of the map).
Square is positioned on map grid with upper left corner at x y
binary_size is the number of binary bytes of map data that will follow the #

BINARY_DATA is the raw binary data.  This involves run-length encoding and 
a few other tricks to reduce it's size.  Check the code in map.cpp for details.




PU
p_id po_id o_id o_origin_valid o_origin_x o_origin_y heat force x y age age_r s c
p_id po_id o_id o_origin_valid o_origin_x o_origin_y heat force x y age age_r s c
p_id po_id o_id o_origin_valid o_origin_x o_origin_y heat force x y age age_r s c
p_id po_id o_id o_origin_valid o_origin_x o_origin_y heat force x y age age_r s c
...
p_id po_id o_id o_origin_valid o_origin_x o_origin_y heat force x y age age_r s c
#

List of player ids with their display object ids, held object ids, 
whether held origin is valid (1 or 0), origin position on map of that held 
object (where it was picked up from), and x,y grid positions of player,
floating point age in "years", floating point aging rate in years/sec, and
floating point s move speeds (in grid square widths per second) and clothing
set.

Heat is the player's warmth between 0 and 1, where 0 is coldest, 1 is hottest,
and 0.5 is ideal.

This means the player is stationary at this position.

force is usually 0 except in special cases of move truncation where it is 1.
A player receiving force for itself must snap back to that location
before continuing to move.

Deleted players reported in update with
X X 
for x y.

Clothing sets are in the format of hat_id,tunic_id,front_shoe_id,back_shoe_id
If an ID is 0, player is not wearing anything in that spot.

If o_id (held object ID) is negative, it represents the p_id of the other
player (baby) that this player is holding.

NOTE:
If a baby wriggles out of an adult's arms, there is no PU sent about
the adult, only about the baby.  The fact that there was a PU about
the baby indicates that they are no longer held by the adult.
This is so PU's can be interpreted as "the player is HERE right now"
and a baby can wriggle out of an adult's arms while the adult is in transit.





PM
p_id xs ys total_sec eta_sec trunc xdelt0 ydelt0 ... xdeltN ydeltN
p_id xs ys total_sec eta_sec trunc xdelt0 ydelt0 ... xdeltN ydeltN
...
p_id xs ys total_sec eta_sec trunc xdelt0 ydelt0 ... xdeltN ydeltN
#

List of player ids that just started moving, their start x y grid position,
their delta grid offsets along their path (xs + xdelt0 = first destination x), 
how long the total move should take (in case we 
come into the game in the middle of a move), and their time to arrival in 
floating point seconds

trunc is 0 for untruncated path, or 1 for truncated path.
Truncated paths are shorter than what the player originally requested.
This can happen in immediate response to the move request or later, mid-move,
if the path gets cut off (a new PM will be sent to truncate the path at that
point)

A PLAYER_UPDATE will be sent when these players reach their destination.
Until that has happened, client must assume player is still in transit.




PS
p_id text
p_id text
p_id text
...
p_id text
#

Text that each player says must not contain # or newline.





MX
x y new_id p_id
x y new_id p_id
x y new_id p_id
...
x y new_id p_id
#

Grid position of changes, and new object id that position must change to.
p_id is the player that was responsible for the change (in the case of an 
object drop only), or -1 if none.

Note that if cell contains other stuff (for a container object), new_id
is a comma-delimited list of contained objects, with the container first
in the list.





FX
food_store food_capacity move_speed
#

store is integer amount of food left in body, capacity is the integer 
maximum amount of food.

move_speed is floating point speed in grid square widths per second.






First message sent upon client new connection to server:

A map chunk message for where the player is standing, followed by 
a full player update message for ALL players on entire server.




Clients send moves in the following format:

USE x y#
SELF x y#
REMV x y#
DROP x y#
KILL x y#


DROP is for setting held object down on empty grid square OR
	 for adding something to a container

USE  is for bare-hand or held-object action on target object in non-empty 
     grid square, including picking something up (if there's no bare-handed 
     action), and picking up a container.

SELF is special case of USE action taken on self (to eat what we're holding
     or add/remove clothing).
     This differentiates between use actions on the object at our feet
     (same grid cell as us) and actions on ourself.

REMV is special case of removing an object from a container.

KILL is for using a deadly object on the target square.  Square can
     be non-adjacent depending on deadly distance of held object.
     If another player is located there (even if moving and crossing)
	 they will be killed.



This one is more complicated:

MOVE xs ys xdelt0 ydelt0 xdelt1 ydelt1 ... xdeltN ydeltN#

xs,ys is the absolute world position the player thinks they're currently at

the pairs of deltas represent steps along an obstacle-free path that the player
wants to take to their destination xdeltN,ydeltN

These deltas are relative to xs,ys and will be rejected if they are larger
than +/- 16 (the maximum allowed path search radius.


Note that USE, DROP, and REMV actions are ignored while a MOVE is in progress 
(until the server sends a PU to indicate that the move is finished and the
 destination has been reached).  SAY can happen during a move, however.




SAY 0 0 text#


SAY text cannot contain the # character and will be truncated at the
    player's age-speech limit (age in years + 1 character).

    The x y parameters to SAY are currently ignored and can be 0, but must
    be present.
